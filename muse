#!/usr/bin/env ruby
#
# Talk to a cvlc server via HTTP commands such as:
#
#   http://satyagraha.sacred.net:9090/requests/status.xml?command=volume&val=100
#
# One starts cvlc server as so:
#
#   cvlc --file-logging --logfile ~/cvlc.txt --daemon --intf http --http-host 0.0.0.0 --http-port 9090 --http-password foo
#
# This client code provides a read-eval-print loop (REPL) that lets
# you communicate with the cvlc server, so that you can maintain a
# playlist, adjust volumes, next/prev/random controls, etc.


require 'json'
require 'rest-client'
require 'uri'
require 'timeout'

$LOAD_PATH.unshift File.dirname(__FILE__)

class MuseError < StandardError; end


require 'command-executor'

@http = 'http://satyagraha.sacred.net:9090/'   # adjust for the address of server.
@pass = 'foo'
@user = ''

MUSIC_ROOT      = '/data/Music'           # Where my music is stored; we'll include this when sending a pathname to the cvlc server, which can look for locally.
STATUS_PAUSE    = 0.25                    # Some commands need a little time to set up, or to complete.  This value should be less than 1 sec, ideally less than 300 msec.
QUICKLY_TIMEOUT = 2.50                    # How long to wait for a response from the CVLC server
STDOUT.sync     = true                    # REPL needs immediate flush

# Top level REPL (Read-Eval-Print Loop).

def main supported_commands
  while true
    write("muse> ")
    command = get()
    goodbye if command.nil?
    response = execute(supported_commands, command)
    writeln(response.chomp) unless response.nil? or response.empty?
  end
rescue => exception
  error_message(supported_commands, exception)
  retry
end

def goodbye
  writeln "Goodbye, and thanks for all the fish!"
  exit
end

def error_message supported_commands, exception
  writeln supported_commands.usage, "\n", exception.message
  unless [ CommandExecutorError, MuseError ].include? exception.class
    writeln exception.class, "\n", exception.backtrace.join("\n")
  end
end

# The 'P' in the REPL: write(text, text...) ship out supplied text
# strings.

def write *text
  STDOUT.write text.flatten.join() unless text.empty?
end

def writeln *text
  write text, "\n"  unless text.empty?
end

# The 'R' in the REPL: get() - reads and cleans up input, exiting if
# EOF has been reached (^D is entered, normally).  Input is returned
# otherwise.

def get
  input = STDIN.gets
  return unless input
  return input.strip
end

# The 'E' in the REPL is mostly done by the CommandExecutor object
# method CommandExecutor#execute(String).
#
# Here we're just fielding any special conditions specific to this
# program.

def execute supported, command
   return supported.execute("play #{command}") if command =~ /^\d+$/
   return supported.execute(command)
end

# The setup_commands() creates the CommandEexcutor object, providing
# all the information needed for executing the functions the user
# enters in the REPL loop, as well as providing help text, etc.

def setup_commands
  commands = CommandExecutor.new

  commands.add('delete',   lambda { |id|  do_delete_id(id) },     Fixnum,  "remove item <num> from the playlist")
  commands.add('play',     lambda { |id|  do_play_id(id) },       Fixnum,  "play item <num> from the playlist")
  commands.add('volume',   lambda { |level|  do_volume(level) },  Fixnum,  "set volume to <num>,  0..300")

  commands.add('add',      lambda { |dir|  do_add(dir) },         String,  "add directory or filename <string> to the playlist, begin playing there")
  commands.add('enqueue',  lambda { |dir|  do_enqueue(dir) },     String,  "add directory or filename <string> to the end of the playlist, continue with current song")
  commands.add('seek',     lambda { |amount|  do_seek(amount) },  String,  "seek +/- seconds or percent - e.g. -10 or +25% ")

  commands.add('?',        lambda { do_help(commands) },          nil,     "this help")
  commands.add('clear',    lambda { do_clear_playlist() },        nil,     "clear the playlist")
  commands.add('list',     lambda { do_list() },                  nil,     "print the current playlist")
  commands.add('loop',     lambda { do_toggle_loop() },           nil,     "toggle looping")
  commands.add('next',     lambda { do_next() },                  nil,     "play next entry on the playlist")
  commands.add('pause',    lambda { do_force_pause() },           nil,     "pause playing")
  commands.add('previous', lambda { do_previous() },              nil,     "play the previous entry")
  commands.add('random',   lambda { do_toggle_random() },         nil,     "toggle random play")
  commands.add('repeat',   lambda { do_toggle_repeat() },         nil,     "toggle repeat")
  commands.add('resume',   lambda { do_force_resume() },          nil,     "resume playing")
  commands.add('status',   lambda { do_status() },                nil,     "pretty print status of cvlc server")
  commands.add('stop',     lambda { do_stop() },                  nil,     "stop playing")

  return commands
end

# Use quickly() as wrapper for time-sensitive operations, esp. for
# communicating over the network with the cvlc server.

def quickly time = QUICKLY_TIMEOUT
  Timeout.timeout(time) do
    yield
  end
rescue Timeout::Error => e
  raise MuseError, "Timed out after #{time} seconds"
end

# remove unuseful junk from a file/directory name

def cleanup_pathname path
  return path.gsub(MUSIC_ROOT, '').gsub(/file:\/+/, '').gsub(/^\/+/, '')
end


def summary status


end

# pretty_status(status) - status is a json-derived hash, print it out somewhat pretty

def pretty_status status
  strings = []
  status.keys.sort.each { |k| strings.push sprintf("%15s: %s", k, status[k].inspect) }
  return strings.join("\n")
end


# get_status() - returns data about the current cvlc status - can be as complex as:
#
# {
#   "loop": false,
#   "audiofilters": {
#     "filter_0": ""
#   },
#   "state": "playing",
#   "equalizer": [
#
#   ],
#   "rate": 1,
#   "random": false,
#   "stats": {
#     "displayedpictures": 0,
#     "sentbytes": 0,
#     "readbytes": 3603606,
#     "demuxcorrupted": 0,
#     "playedabuffers": 431,
#     "decodedvideo": 0,
#     "sendbitrate": 0,
#     "averagedemuxbitrate": 0,
#     "lostpictures": 0,
#     "demuxreadbytes": 3451489,
#     "readpackets": 343,
#     "lostabuffers": 0,
#     "demuxbitrate": 0.085678078234196,
#     "averageinputbitrate": 0,
#     "demuxdiscontinuity": 0,
#     "sentpackets": 0,
#     "inputbitrate": 0.080183073878288,
#     "demuxreadpackets": 0,
#     "decodedaudio": 431
#   },
#   "version": "2.1.4 Rincewind",
#   "time": 40,
#   "currentplid": 76,
#   "videoeffects": {
#     "saturation": 1,
#     "contrast": 1,
#     "gamma": 1,
#     "hue": 0,
#     "brightness": 1
#   },
#   "position": 0.10163500159979,
#   "volume": 90,
#   "length": 394,
#   "audiodelay": 0,
#   "apiversion": 3,
#   "subtitledelay": 0,
#   "repeat": false,
#   "information": {
#     "chapters": [
#
#     ],
#     "category": {
#       "meta": {
#         "ISRC": "USU2C1000002",
#         "track_number": "2",
#         "title": "Escape Artist",
#         "description": "Visit http://music.zoekeating.com",
#         "artwork_url": "file:///home/fischer/.cache/vlc/art/artistalbum/Zoe%20Keating/Into%20The%20Trees/art.jpg",
#         "date": "2010",
#         "album": "Into The Trees",
#         "COMMENT": "Visit http://music.zoekeating.com",
#         "artist": "Zoe Keating",
#         "filename": "Escape Artist",
#         "ALBUMARTIST": "Zoe Keating"
#       },
#       "Stream 0": {
#         "Channels": "Stereo",
#         "Type": "Audio",
#         "Codec": "FLAC (Free Lossless Audio Codec) (flac)",
#         "Bits_per_sample": "16",
#         "Sample_rate": "44100 Hz"
#       }
#     },
#     "titles": [
#
#     ],
#     "title": 0,
#     "chapter": 0
#   },
#   "fullscreen": 0
# }

def get_status
  return JSON.parse(do_command('requests/status.json'))
end

# get_playlist()  interrogates the cvlc web service and returns a list of music on the
# current playlist;  elements of the list look as so:
#
# {
#   "uri": "file:///data/Music/Zo%C3%AB%20Keating/Into%20the%20Trees/01.%20Forest.flac",
#   "id": "75",
#   "type": "leaf",
#   "duration": 45,
#   "current": "current",
#   "ro": "rw",
#   "name": "Forest"
# },
#
# The empty playlist appears as so (if music were on the playlist, they'd be under node-id 2, in the children array):
#
# {
#   "id": "1",
#   "type": "node",
#   "name": "Undefined",
#   "ro": "rw"
#   "children": [
#                  {
#                    "children": [       ],
#                    "id": "2",
#                    "type": "node",
#                    "name": "Playlist",
#                    "ro": "ro"
#                  },
#
#                  {
#                    "children": [       ],
#                    "id": "3",
#                    "type": "node",
#                    "name": "Media Library",
#                    "ro": "ro"
#                  }
#              ],
# }
#


def get_playlist
  playlist = JSON.parse(do_command('requests/playlist.json'))
  inner    = playlist['children'].first
  output   = []

  if inner['name'] =~ /playlist/i and inner['children'].class == Array
     inner['children'].each do |elt|
       next unless elt['type'] == 'leaf'
       next if elt['uri']  == 'vlc://nop'
       output.push elt
     end
  else
    raise MuseError, "Unexpected playlist output: \n" + JSON.pretty_generate(playlist)
  end
  return output
end


# id_now_playing(status) examines the status data structure returned
# by the cvlc service, and returns the id of the song in the playlist
# currently playing. If nothing is playing, it returns nil.

def id_now_playing status
  return (status['state'] == 'playing' ? status['currentplid'].to_i.to_s : nil)
end


# currently_playing() returns a pretty string indicating the song
# playing, or, if nothing is playing, the string 'idle'

def currently_playing
  sleep STATUS_PAUSE
  status = get_status()
  get_playlist().each do |elt|
    if elt['id'].to_s == id_now_playing(status)
      return sprintf("*   %03d -  %s", elt['id'], cleanup_pathname(URI.decode(elt['uri'])))
    end
  end
  return 'idle'
end


# Command actually ships the command out to the cvlc server, used by top-level instructions

def do_command command
  command  = [ @http, command ].join
  resource =  RestClient::Resource.new(command, @user, @pass)

  response = quickly do
    res = resource.get
    raise MuseError, "Bad response code #{response.code} for command '#{command}'" unless res.code < 300
    res
  end

  return response
rescue => e
  raise MuseError, "do_command: #{e}\n" + "do_command: Error tyrying to communicate wth the cvlc media service (is it running?)."
end

## Top level commands

# do_list() returns the playlist pretty-printed, highlighting the
# currently playing entry (if one is being played) with an
# asterisk. Empty return text is possible.

def do_list
  status = get_status()
  output = []
  get_playlist().each do |elt|
    marker = (elt['id'].to_s == id_now_playing(status) ? '*' : ' ')
    output.push sprintf("%s   %03d -  %s\n", marker, elt['id'], cleanup_pathname(URI.decode(elt['uri'])))
  end
  return output.join
end

# do_add(name) - add the
# name should not include full URI path (TODO: we'll have to make it
# do so at some point when we make this a class)

def do_add pathname
  raise MuseError, "No such file or directory '{pathname}'" unless File.exists? "#{MUSIC_ROOT}/#{pathname}"
  string = URI.encode(pathname.sub(%r{/+$},'')).gsub('&', '%26')
  do_command("requests/status.json?command=in_play&input=file://#{MUSIC_ROOT}/#{string}&option=novideo")
  return currently_playing()
end

# do_status() - returns a compact list of the returned json.

def do_status
  return pretty_status(get_status)
end

# do_next() - do next entry on playlist, wraps around

def do_next
  do_command('requests/status.json?command=pl_next')
  return currently_playing()
end

# do_previous() - do previous entry on playlist, wraps around

def do_previous
  do_command('requests/status.json?command=pl_previous')
  return currently_playing()
end

def do_play_id id
  do_command("requests/status.json?command=pl_play&id=#{id.to_i}")
  return currently_playing()
end

def do_delete_id id
  do_command("requests/status.json?command=pl_delete&id=#{id.to_i}")
  return currently_playing()
end

def do_raw_list
  return JSON.pretty_generate(JSON.parse(do_command('requests/playlist.json')))
end

def do_clear_playlist
  do_command('requests/status.json?command=pl_empty')
  return
end

def do_toggle_random
  do_command('requests/status.json?command=pl_random')
  return currently_playing()
end

def do_toggle_loop
  do_command('requests/status.json?command=pl_loop')
  return
end

def do_toggle_repeat
  do_command('requests/status.json?command=pl_repeat')
  return currently_playing()
end

def do_seek amount
  if amount =~ %r{^[+-]?\d+\%?$}
    do_command("requests/status.json?command=seek&val=#{URI.encode(amount)}")
  else
    raise MuseError, "Ill-formed seek amount '#{amount}'"
  end
  return
end

# the scoping for using this is pretty atrocious, see setup_commands

def do_help commands
  return commands.usage
end

def do_art
  art = do_command('art');
  return art.inspect
end

def do_enqueue pathname
  string = URI.encode(pathname.sub(%r{/+$},''))
  do_command("requests/status.json?command=in_enqueue&input=#{MUSIC_ROOT}/#{string}")
  return currently_playing()
end

# Doesn't seem to work

def do_bonjour
  return pretty_status(JSON.parse(do_command('requests/status.json?command=pl_sd&val=bonjour')))
end

# TODO: add this to commands....

def do_raw_command
  return unless command
  return pretty_status(JSON.parse(do_command(command)))
end

def do_stop
  do_command('requests/status.json?command=pl_stop')
  return
end

def do_force_pause
  do_command('requests/status.json?command=pl_forcepause')
  return
end

def do_force_resume
  do_command('requests/status.json?command=pl_forceresume')
  return
end


# TODO: need to document this better....
#
# if num,  then must be <= 250
# if +num, then current volume must be  <= 250 - num
# don't care about -num
#
# 100 == 0 for some reason...


def do_volume num
  raise MuseError, "The 'volume' command requires an integer value between 1 and 300..." if num.to_i > 300
  raise MuseError, "The 'volume' command requires an integer value between 1 and 300..." if num.to_i < 1

  do_command("requests/status.json?command=volume&val=#{num}")
  sleep STATUS_PAUSE
  return pretty_status(get_status())
end


main(setup_commands)
