#!/usr/bin/env ruby
#
# Talk to a cvlc server via HTTP commands such as:
#
#      http://satyagraha.sacred.net:9090/requests/status.xml?command=volume&val=100
#
# On starts cvlc server as so:
#
#   cvlc --file-logging --logfile ~/cvlc.txt --daemon --intf http --http-host 0.0.0.0 --http-port 9090 --http-password foo
#
# This client code provides a read-eval-print loop (REPL) that lets
# you communicate with the cvlc server, so that you can maintain a
# playlist, adjust volumes, next/prev/random controls, etc.


require 'json'
require 'rest-client'
require 'uri'
require 'timeout'

$LOAD_PATH.unshift File.dirname(__FILE__)

require 'trie'

@http = 'http://satyagraha.sacred.net:9090/'   # adjust for the address of your server.
@pass = 'foo'
@user = ''

MUSIC_ROOT      = 'file:///data/Music/'   # Where my music is stored; we'll include this when sending a pathname to the cvlc server, which can look for locally.
STATUS_PAUSE    = 0.25                    # Some commands need a little time to set up, or to complete.  This value should be less than 1 sec, ideally less than 300 msec.
QUICKLY_TIMEOUT = 2.50                    #
STDOUT.sync     = true                    # REPL needs immediate flush

# Top level REPL (Read-Eval-Print Loop).

def main
  available_commands = setup_commands()
  while true
    write("muse> ")
    response = execute(available_commands, get())
    write(response, "\n") unless response.nil? or response.empty?
  end
rescue => e
  write(e, "\n\n")
  usage(available_commands)
  retry
end


# The setup_commands() creates a TRIE (a specialized kind of Key/Value
# hash) that provides all the information needed for executing the
# functions the user enters in the REPL loop.

def setup_commands
  commands = Trie.new

  commands['delete']      =  { :name => 'delete',   :command => lambda { |id|  do_delete_id(id) },     :argument => Fixnum, :help => "remove item <num> from the playlist" }
  commands['play']        =  { :name => 'play',     :command => lambda { |id|  do_play_id(id) },       :argument => Fixnum, :help => "play item <num> from the playlist" }
  commands['volume']      =  { :name => 'volume',   :command => lambda { |level|  do_volume(level) },  :argument => Fixnum, :help => "set volume to <num>,  0..300" }

  commands['add']         =  { :name => 'add',      :command => lambda { |dir|  do_add(dir) },         :argument => String, :help => "add directory or filename <string> to the playlist, begin playing" }
  commands['enqueue']     =  { :name => 'enqueue',  :command => lambda { |dir|  do_enqueue(dir) },     :argument => String, :help => "add directory or filename <string> to the end of the playlist" }

  commands['?']           =  { :name => '?',        :command => lambda { do_help(commands) },          :argument => nil,    :help => "this help" }
  commands['clear']       =  { :name => 'clear',    :command => lambda { do_clear_playlist() },        :argument => nil,    :help => "clear the playlist" }
  commands['list']        =  { :name => 'list',     :command => lambda { do_list() },                  :argument => nil,    :help => "print the current playlist" }
  commands['loop']        =  { :name => 'loop',     :command => lambda { do_toggle_loop() },           :argument => nil,    :help => "toggle looping" }
  commands['next']        =  { :name => 'next',     :command => lambda { do_next() },                  :argument => nil,    :help => "play next entry on the playlist" }
  commands['previous']    =  { :name => 'previous', :command => lambda { do_previous() },              :argument => nil,    :help => "play the previous entry" }
  commands['random']      =  { :name => 'random',   :command => lambda { do_toggle_random() },         :argument => nil,    :help => "toggle random play" }
  commands['repeat']      =  { :name => 'repeat',   :command => lambda { do_toggle_repeat() },         :argument => nil,    :help => "toggle repeat" }
  commands['status']      =  { :name => 'status',   :command => lambda { do_status() },                :argument => nil,    :help => "pretty print status of cvlc server" }

  return commands
end

# The 'P' in the REPL: write(text, text...) ship out supplied text
# strings.

def write *text
  STDOUT.write text.join() unless text.empty?
end

# The 'R' in the REPL: get() - reads and cleans up input, exiting if
# EOF has been reached (^D is entered, normally).  Input is returned
# otherwise.

def get
  input = STDIN.gets
  if input.nil?
    write "Goodbye, and thanks for all the fish!\n"
    exit
  end
  return input.strip
end

# The 'E' in the REPL: execute("command [arg]") - expect input to be
# "command" or "command data..."; Run the command's associated method
# after cleaning up input and possibly separating out the argument.
# Return whatever the particular command executed returns.

def execute commands, input

  command, argument = input.strip.split(/\s+/, 2)

  # special cases:

  return if not  command
  return do_play_id(command)  if command =~ /^\d+$/ and argument.nil?

  completions = commands.completions(command)

  case completions.count
  when 0
    usage(commands)
    puts "This program doesn't know how to '#{command}'."
    return

  when 1
    record   = completions[0][1]
    thunk    = record[:command]
    argtype  = record[:argument]

    errors = argument_errors(command, argument, argtype)

    if errors
      usage(commands)
      puts errors
      return
    end

    return thunk.call()              if argtype == nil
    return thunk.call(argument.to_i) if argtype == Fixnum
    return thunk.call(argument.to_s) if argtype == String

    raise "Don't know what to do... for arguments of class '#{argtype}'"
  else
    puts "'#{input}' is ambiguous (could be '#{completions.map{ |rec| rec[0] }.join("', '")}')."
    return nil
  end
end


def argument_errors name, argval, argtype

  return case
         when (not argval.nil? and argtype.nil? )
           "The '#{name}' command takes no arguments."
         when ((argval !~ /^\d+$/ and argtype == Fixnum) or (argval.nil? and argtype == Fixnum))
           "The '#{name}' command takes a number as an argument."
         when (argval.nil? and argtype == String)
           "The '#{name}' command takes a string as an argument."
         else
           nil
         end
end



def usage commands

  usage_notes = []

  commands.values.each do |rec|
    usage = rec[:name]               if rec[:argument] == nil
    usage = rec[:name] + " <num>"    if rec[:argument] == Fixnum
    usage = rec[:name] + " <string>" if rec[:argument] == String
    usage_notes.push( { :signature => usage, :help => rec[:help] } )
  end

  max = usage_notes.map { |rec| rec[:signature].length }.max
  puts "Usage:"
  usage_notes.each { |rec| puts sprintf("%#{max + 1}s:  %s", rec[:signature], rec[:help]) }
  puts ''
  return nil
end


# Use quickly() as wrapper for time-sensitive operations, esp. for
# communicating over the network with the cvlc server.

def quickly time = QUICKLY_TIMEOUT
  Timeout.timeout(time) do
    yield
  end
rescue Timeout::Error => e
  raise "Timed out after #{time} seconds"
end

# pretty_status(status) - status is a json-derived hash, print it out somewhat pretty

def pretty_status status
  strings = []
  status.keys.sort.each { |k| strings.push sprintf("%15s: %s", k, status[k].inspect) }
  return strings.join("\n")
end



# get_status() - returns data about the current cvlc status - can be as complex as:
#
# {
#   "loop": false,
#   "audiofilters": {
#     "filter_0": ""
#   },
#   "state": "playing",
#   "equalizer": [
#
#   ],
#   "rate": 1,
#   "random": false,
#   "stats": {
#     "displayedpictures": 0,
#     "sentbytes": 0,
#     "readbytes": 3603606,
#     "demuxcorrupted": 0,
#     "playedabuffers": 431,
#     "decodedvideo": 0,
#     "sendbitrate": 0,
#     "averagedemuxbitrate": 0,
#     "lostpictures": 0,
#     "demuxreadbytes": 3451489,
#     "readpackets": 343,
#     "lostabuffers": 0,
#     "demuxbitrate": 0.085678078234196,
#     "averageinputbitrate": 0,
#     "demuxdiscontinuity": 0,
#     "sentpackets": 0,
#     "inputbitrate": 0.080183073878288,
#     "demuxreadpackets": 0,
#     "decodedaudio": 431
#   },
#   "version": "2.1.4 Rincewind",
#   "time": 40,
#   "currentplid": 76,
#   "videoeffects": {
#     "saturation": 1,
#     "contrast": 1,
#     "gamma": 1,
#     "hue": 0,
#     "brightness": 1
#   },
#   "position": 0.10163500159979,
#   "volume": 90,
#   "length": 394,
#   "audiodelay": 0,
#   "apiversion": 3,
#   "subtitledelay": 0,
#   "repeat": false,
#   "information": {
#     "chapters": [
#
#     ],
#     "category": {
#       "meta": {
#         "ISRC": "USU2C1000002",
#         "track_number": "2",
#         "title": "Escape Artist",
#         "description": "Visit http://music.zoekeating.com",
#         "artwork_url": "file:///home/fischer/.cache/vlc/art/artistalbum/Zoe%20Keating/Into%20The%20Trees/art.jpg",
#         "date": "2010",
#         "album": "Into The Trees",
#         "COMMENT": "Visit http://music.zoekeating.com",
#         "artist": "Zoe Keating",
#         "filename": "Escape Artist",
#         "ALBUMARTIST": "Zoe Keating"
#       },
#       "Stream 0": {
#         "Channels": "Stereo",
#         "Type": "Audio",
#         "Codec": "FLAC (Free Lossless Audio Codec) (flac)",
#         "Bits_per_sample": "16",
#         "Sample_rate": "44100 Hz"
#       }
#     },
#     "titles": [
#
#     ],
#     "title": 0,
#     "chapter": 0
#   },
#   "fullscreen": 0
# }

def get_status
  return JSON.parse(do_command('requests/status.json'))
end

# get_playlist()  interrogates the cvlc web service and returns a list of music on the
# current playlist;  elements of the list look as so:
#
# {
#   "uri": "file:///data/Music/Zo%C3%AB%20Keating/Into%20the%20Trees/01.%20Forest.flac",
#   "id": "75",
#   "type": "leaf",
#   "duration": 45,
#   "current": "current",
#   "ro": "rw",
#   "name": "Forest"
# },
#
# The empty playlist appears as so (if music were on the playlist, they'd be under node-id 2, in the children array):
#
# {
#   "id": "1",
#   "type": "node",
#   "name": "Undefined",
#   "ro": "rw"
#   "children": [
#                  {
#                    "children": [       ],
#                    "id": "2",
#                    "type": "node",
#                    "name": "Playlist",
#                    "ro": "ro"
#                  },
#
#                  {
#                    "children": [       ],
#                    "id": "3",
#                    "type": "node",
#                    "name": "Media Library",
#                    "ro": "ro"
#                  }
#              ],
# }
#


def get_playlist
  playlist = JSON.parse(do_command('requests/playlist.json'))
  inner    = playlist['children'].first
  output   = []

  if inner['name'] =~ /playlist/i and inner['children'].class == Array
     inner['children'].each do |elt|
       next unless elt['type'] == 'leaf'
       next if elt['uri']  == 'vlc://nop'
       output.push elt
     end
  else
    raise "Unexpected playlist output: \n" + JSON.pretty_generate(playlist)
  end
  return output
end


# id_now_playing(status) examines the status data structure returned
# by the cvlc service, and returns the id of the song in the playlist
# currently playing. If nothing is playing, it returns nil.

def id_now_playing status
  return (status['state'] == 'playing' ? status['currentplid'].to_i.to_s : nil)
end

# currently_playing() returns a pretty string indicating the song
# playing, or, if nothing is playing, the string 'idle'

def currently_playing
  sleep STATUS_PAUSE
  status = get_status()
  get_playlist().each do |elt|
    if elt['id'].to_s == id_now_playing(status)
      return sprintf("*   %03d -  %s", elt['id'], URI.decode(elt['uri'].gsub(MUSIC_ROOT, '').gsub(/^\/+/, '')))
    end
  end
  return 'idle'
end


# Command actually ships the command out to the cvlc server, used by top-level instructions

def do_command command
  command  = [ @http, command ].join
  resource =  RestClient::Resource.new(command, @user, @pass)

  response = quickly do
    res = resource.get
    raise "Bad response code #{response.code} for command '#{command}'" unless res.code < 300
    res
  end

  return response
rescue => e
  write "do_command: #{e}\n"
  puts  "do_command: Error tyrying to communicate wth the cvlc media service (is it running?)."
  return nil
end



## Top level commands

# do_list() returns the playlist pretty-printed, highlighting the
# currently playing entry (if one is being played) with an
# asterisk. Empty return text is possible.

def do_list
  status = get_status()
  output = []
  get_playlist().each do |elt|
    marker = (elt['id'].to_s == id_now_playing(status) ? '*' : ' ')
    output.push sprintf("%s   %03d -  %s", marker, elt['id'], URI.decode(elt['uri'].gsub(MUSIC_ROOT, '').gsub(/^\/+/, '')))
  end
  return output.join("\n")
end

# do_add(name) - add the
# name should not include full URI path (TODO: we'll have to make it
# do so at some point when we make this a class)

def do_add pathname = nil
  raise "add requires a pathname" if pathname.nil?
  #  raise "No such file or directory '#{pathname}'" unless File.exists? "#{MUSIC_ROOT}/#{pathname}"
  string = URI.encode(pathname.sub(%r{/+$},''))
  do_command("requests/status.json?command=in_play&input=#{MUSIC_ROOT}/#{string}&option=novideo")
  return currently_playing()
end

# do_status() - returns a compact list of the returned json.

def do_status
  return pretty_status(get_status)
end

# do_next() - do next entry on playlist, wraps around

def do_next
  do_command('requests/status.json?command=pl_next')
  return currently_playing()
end

# do_previous() - do previous entry on playlist, wraps around

def do_previous
  do_command('requests/status.json?command=pl_previous')
  return currently_playing()
end

def do_play_id id
  do_command("requests/status.json?command=pl_play&id=#{id.to_i}")
  return currently_playing()
end

def do_delete_id id
  do_command("requests/status.json?command=pl_delete&id=#{id.to_i}")
  return currently_playing()
end

def do_raw_list
  return JSON.pretty_generate(JSON.parse(do_command('requests/playlist.json')))
end

def do_clear_playlist
  do_command('requests/status.json?command=pl_empty')
  return
end

def do_toggle_random
  do_command('requests/status.json?command=pl_random')
  return currently_playing()
end

def do_toggle_loop
  do_command('requests/status.json?command=pl_loop')
  return
end

def do_toggle_repeat
  do_command('requests/status.json?command=pl_repeat')
  return currently_playing()
end

def do_help commands
  usage(commands)
  return
end

def do_art
  art = do_command('art');
  return art.inspect
end

def do_enqueue pathname = nil
  raise "enqueue requires a pathname" if pathname.nil?
  string = URI.encode(pathname.sub(%r{/+$},''))
  do_command("requests/status.json?command=in_enqueue&input=#{MUSIC_ROOT}/#{string}")
  return currently_playing()
end

def do_bonjour
  return pretty_status(JSON.parse(do_command('requests/status.json?command=pl_sd&val=bonjour')))
end

def do_raw_command
  return unless command
  return pretty_status(JSON.parse(do_command(command)))
end


# TODO: need to document this better....
#
# if num,  then must be <= 250
# if +num, then current volume must be  <= 250 - num
# don't care about -num
#
# 100 == 0 for some reason...


def do_volume num = nil
  raise "volume requires an integer value between 1 and 300..." if num.nil?
  raise "volume requires an integer value between 1 and 300..." if num.to_i > 300
  raise "volume requires an integer value between 1 and 300..." if num.to_i < 1

  do_command("requests/status.json?command=volume&val=#{num}")
  sleep STATUS_PAUSE
  return pretty_status(get_status())
end



main()
